<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D å®ˆå®®é£¼é¤Šç®±äº’å‹•æ¨¡å‹ </title>
    <style>
        /* --- CSS æ¨£å¼å€ --- */
        :root {
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --text-main: #e0e0e0;
            --text-dim: #a0a0a0;
            --accent: #4caf50;
            --accent-hover: #66bb6a;
            --border: #333;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        /* é€šç”¨å…ƒä»¶ */
        h2, h3 { margin-bottom: 1rem; font-weight: 500; letter-spacing: 1px; }
        label { display: block; margin-bottom: 0.5rem; color: var(--text-dim); font-size: 0.9rem; }
        
        button {
            background: var(--panel-bg);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 10px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            width: 100%;
            margin-bottom: 8px;
            text-align: left;
            display: flex;
            align-items: center;
        }
        button:hover { background: #2c2c2c; border-color: var(--accent); }
        button.active { background: var(--accent); color: white; border-color: var(--accent); }
        button i { margin-right: 10px; }

        input[type="color"] {
            width: 100%;
            height: 35px;
            border: none;
            background: none;
            cursor: pointer;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }

        .panel {
            width: 280px;
            background-color: var(--panel-bg);
            padding: 20px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border);
            overflow-y: auto;
            z-index: 10;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
        }

        .right-panel {
            border-right: none;
            border-left: 1px solid var(--border);
            box-shadow: -2px 0 10px rgba(0,0,0,0.3);
        }

        #main-viewport {
            flex-grow: 1;
            position: relative;
            background: radial-gradient(circle at center, #2a2a2a 0%, #000000 100%);
        }
        
        #canvas-container { width: 100%; height: 100%; display: block; }

        .control-group {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }
        .control-group:last-child { border-bottom: none; }

        /* æ¨¡å¼åˆ‡æ›æŒ‰éˆ•ç¾¤çµ„ */
        .mode-toggle { display: flex; gap: 5px; margin-bottom: 15px; }
        .mode-toggle button { text-align: center; justify-content: center; margin-bottom: 0; }

        .hint {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-top: 10px;
            line-height: 1.4;
            background: #2a2a2a;
            padding: 10px;
            border-radius: 4px;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div class="panel left-panel">
        <h2>ç‰©ä»¶é¸å–®</h2>
        <div class="control-group">
            <h3>ç”Ÿç‰©</h3>
            <button id="add-gecko">ğŸ¦ æ–°å¢å®ˆå®®</button>
        </div>
        <div class="control-group">
            <h3>ç’°å¢ƒä½ˆæ™¯</h3>
            <button id="add-rock">ğŸª¨ æ–°å¢é€ æ™¯çŸ³</button>
            <button id="add-plant">ğŸŒ¿ æ–°å¢æ¤ç‰©</button>
            <button id="add-cave">ğŸ  æ–°å¢èº²é¿å±‹</button>
            <button id="add-bowl">ğŸ¥£ æ–°å¢æ°´ç›†</button>
        </div>
        <div class="hint">
            <strong>æ“ä½œèªªæ˜ï¼š</strong><br>
            â€¢ å·¦éµé»æ“Šç‰©ä»¶ï¼šé¸å–<br>
            â€¢ å·¦éµæ‹–æ›³ï¼šæ—‹è½‰è¦–è§’<br>
            â€¢ å³éµæ‹–æ›³ï¼šå¹³ç§»è¦–è§’<br>
            â€¢ æ»¾è¼ªï¼šç¸®æ”¾è¦–è§’
        </div>
    </div>

    <div id="main-viewport">
        <canvas id="canvas-container"></canvas>
    </div>

    <div class="panel right-panel">
        <h2>ç·¨è¼¯é¢æ¿</h2>
        
        <div id="no-selection" style="display: block; color: var(--text-dim); text-align: center; margin-top: 50px;">
            è«‹é»æ“Šç•«é¢ä¸­çš„ç‰©ä»¶<br>é€²è¡Œç·¨è¼¯
        </div>

        <div id="edit-controls" style="display: none;">
            <div class="control-group">
                <h3>æ“ä½œæ¨¡å¼</h3>
                <div class="mode-toggle">
                    <button id="mode-translate" class="active" title="ç§»å‹• (Translate)">ç§»å‹•</button>
                    <button id="mode-rotate" title="æ—‹è½‰ (Rotate)">æ—‹è½‰</button>
                    <button id="mode-scale" title="ç¸®æ”¾ (Scale)">ç¸®æ”¾</button>
                </div>
            </div>

            <div class="control-group">
                <h3>å¤–è§€è¨­å®š</h3>
                <label>é¡è‰²</label>
                <input type="color" id="obj-color" value="#ffffff">
            </div>

            <div class="control-group">
                <h3>åŠŸèƒ½</h3>
                <button id="delete-obj" style="border-color: #ff5252; color: #ff5252;">ğŸ—‘ï¸ åˆªé™¤ç‰©ä»¶</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // å…¨åŸŸè®Šæ•¸
        let scene, camera, renderer;
        let orbitControls, transformControls;
        let raycaster, mouse;
        let selectedObject = null;
        const objects = []; // å­˜æ”¾æ‰€æœ‰å¯äº’å‹•çš„ç‰©ä»¶

        // DOM å…ƒç´ 
        const editPanel = document.getElementById('edit-controls');
        const noSelectionMsg = document.getElementById('no-selection');
        const colorInput = document.getElementById('obj-color');

        init();
        animate();

        function init() {
            // 1. å ´æ™¯è¨­å®š
            const container = document.getElementById('main-viewport');
            scene = new THREE.Scene();
            
            // 2. ç›¸æ©Ÿè¨­å®š
            camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 0.1, 1000);
            camera.position.set(20, 15, 30);
            camera.lookAt(0, 0, 0);

            // 3. æ¸²æŸ“å™¨è¨­å®š
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas-container'), antialias: true, alpha: true });
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // 4. ç‡ˆå…‰
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // æŸ”å’Œç’°å¢ƒå…‰
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 2);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 5. å»ºç«‹é£¼é¤Šç®± (ç»ç’ƒç®±)
            createTerrarium();

            // 6. æ§åˆ¶å™¨
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            
            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', function (event) {
                orbitControls.enabled = !event.value; // æ‹–æ›³ç‰©ä»¶æ™‚ç¦ç”¨è¦–è§’è½‰å‹•
            });
            transformControls.addEventListener('change', () => {
                // ç•¶ç‰©ä»¶è¢«è®Šæ›æ™‚ï¼Œå¦‚æœéœ€è¦æ›´æ–°æ•¸å€¼é¢æ¿å¯ä»¥åœ¨é€™è£¡å¯«
            });
            scene.add(transformControls);

            // 7. äº’å‹•äº‹ä»¶ (Raycaster)
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('resize', onWindowResize);

            // UI äº‹ä»¶ç¶å®š
            setupUIEvents();
        }

        function createTerrarium() {
            // åœ°æ¿
            const floorGeometry = new THREE.PlaneGeometry(30, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3e2723, // åœŸå£¤è‰²
                roughness: 0.9 
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            floor.name = "Floor";
            scene.add(floor);

            // ç»ç’ƒç‰† (é€æ˜ç›’)
            const glassGeometry = new THREE.BoxGeometry(30, 15, 20);
            const glassMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.1,
                roughness: 0,
                metalness: 0.1,
                side: THREE.BackSide // è®“å…§éƒ¨å¯è¦‹
            });
            const glassBox = new THREE.Mesh(glassGeometry, glassMaterial);
            glassBox.position.y = 7.5;
            scene.add(glassBox);

            // é‚Šæ¡† (è£é£¾ç”¨)
            const edges = new THREE.EdgesGeometry(glassGeometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
            line.position.y = 7.5;
            scene.add(line);
        }

        // --- ç‰©ä»¶ç”Ÿæˆå·¥å»  ---

        // ç”Ÿæˆéš¨æ©Ÿé¡è‰²
        const randomColor = () => Math.random() * 0xffffff;

        function createGecko() {
            const group = new THREE.Group();

            const material = new THREE.MeshStandardMaterial({ color: 0xffab91, roughness: 0.4 }); // å®ˆå®®è†šè‰²

            // èº«é«”
            const bodyGeo = new THREE.CapsuleGeometry(0.8, 3, 4, 8);
            const body = new THREE.Mesh(bodyGeo, material);
            body.rotation.x = Math.PI / 2;
            body.castShadow = true;
            group.add(body);

            // é ­
            const headGeo = new THREE.SphereGeometry(1, 16, 16);
            const head = new THREE.Mesh(headGeo, material);
            head.position.z = -2;
            head.scale.set(1, 0.6, 1);
            head.castShadow = true;
            group.add(head);

            // çœ¼ç›
            const eyeGeo = new THREE.SphereGeometry(0.2);
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(0.6, 0.3, -2.2);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(-0.6, 0.3, -2.2);
            group.add(leftEye);
            group.add(rightEye);

            // å°¾å·´
            const tailGeo = new THREE.ConeGeometry(0.5, 4, 8);
            const tail = new THREE.Mesh(tailGeo, material);
            tail.rotation.x = -Math.PI / 2;
            tail.position.z = 3.5;
            tail.castShadow = true;
            group.add(tail);

            // ç°¡å–®çš„å››è‚¢ (ç”¨å°è† å›Šä»£è¡¨)
            const legGeo = new THREE.CapsuleGeometry(0.3, 1);
            const legPositions = [
                {x: 1, z: -1}, {x: -1, z: -1},
                {x: 1, z: 1.5}, {x: -1, z: 1.5}
            ];
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeo, material);
                leg.position.set(pos.x, -0.2, pos.z);
                leg.rotation.z = Math.PI / 2;
                leg.rotation.y = (pos.x > 0 ? -1 : 1) * 0.5;
                group.add(leg);
            });

            group.userData = { type: 'gecko', isEditable: true };
            spawnObject(group);
        }

        function createRock() {
            // ä½¿ç”¨åäºŒé¢é«”æ¨¡æ“¬çŸ³é ­
            const geometry = new THREE.DodecahedronGeometry(Math.random() * 1 + 1, 0);
            const material = new THREE.MeshStandardMaterial({ color: 0x8d6e63, flatShading: true });
            const mesh = new THREE.Mesh(geometry, material);
            
            // éš¨æ©Ÿè®Šå½¢
            mesh.scale.set(1 + Math.random(), 0.8, 1 + Math.random());
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = { type: 'rock', isEditable: true };
            spawnObject(mesh);
        }

        function createPlant() {
            const group = new THREE.Group();
            // è–
            const stemGeo = new THREE.CylinderGeometry(0.1, 0.1, 1);
            const greenMat = new THREE.MeshStandardMaterial({ color: 0x66bb6a });
            const stem = new THREE.Mesh(stemGeo, greenMat);
            stem.position.y = 0.5;
            group.add(stem);

            // è‘‰å­ (ç”¨å¹¾å€‹å£“æ‰çš„çƒé«”)
            for(let i=0; i<5; i++) {
                const leafGeo = new THREE.SphereGeometry(0.4, 8, 8);
                const leaf = new THREE.Mesh(leafGeo, greenMat);
                leaf.position.y = 0.8 + Math.random() * 0.5;
                leaf.position.x = (Math.random() - 0.5) * 1.5;
                leaf.position.z = (Math.random() - 0.5) * 1.5;
                leaf.scale.y = 0.1;
                leaf.rotation.x = Math.random();
                leaf.rotation.z = Math.random();
                group.add(leaf);
            }

            group.userData = { type: 'plant', isEditable: true };
            spawnObject(group);
        }

        function createCave() {
            // èº²é¿å±‹ï¼šåˆ‡åŠçš„çƒé«”
            const geometry = new THREE.SphereGeometry(3, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const material = new THREE.MeshStandardMaterial({ color: 0x5d4037, side: THREE.DoubleSide });
            const cave = new THREE.Mesh(geometry, material);
            cave.castShadow = true;
            
            // å…¥å£ (ç°¡å–®ç”¨å¦ä¸€å€‹é»‘æ´è“‹ä¸Šå»ï¼Œæˆ–è€…åªæ˜¯è¦–è¦ºä¸Šçš„å½¢ç‹€)
            // é€™è£¡ç°¡åŒ–ç‚ºä¸€å€‹åŠçƒé«”å¤–æ®¼
            
            cave.userData = { type: 'cave', isEditable: true };
            spawnObject(cave);
        }

        function createBowl() {
            const geometry = new THREE.CylinderGeometry(1.5, 1.2, 0.5, 16);
            const material = new THREE.MeshStandardMaterial({ color: 0xffcc80 });
            const bowl = new THREE.Mesh(geometry, material);
            
            // æ°´é¢
            const waterGeo = new THREE.CircleGeometry(1.1, 16);
            const waterMat = new THREE.MeshStandardMaterial({ color: 0x4fc3f7 });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI / 2;
            water.position.y = 0.26;
            bowl.add(water);

            bowl.castShadow = true;
            bowl.userData = { type: 'bowl', isEditable: true };
            spawnObject(bowl);
        }

        // é€šç”¨ç”Ÿæˆå‡½æ•¸
        function spawnObject(obj) {
            // é è¨­ä½ç½®åœ¨ä¸­å¿ƒä¸Šæ–¹
            obj.position.set((Math.random()-0.5)*5, 0.5, (Math.random()-0.5)*5);
            
            // å¦‚æœæ˜¯ç¾¤çµ„ï¼Œéœ€è¦éæ­·å­ç‰©ä»¶è³¦äºˆæè³ªåƒè€ƒï¼Œä»¥ä¾¿å¾ŒçºŒè®Šè‰²
            // å¦‚æœæ˜¯å–®ä¸€ Meshï¼Œç›´æ¥å°±å¯ä»¥è®Šè‰²
            
            scene.add(obj);
            objects.push(obj);
            
            // è‡ªå‹•é¸å–å‰›ç”Ÿæˆçš„ç‰©ä»¶
            selectObject(obj);
        }

        // --- äº’å‹•é‚è¼¯ ---

        function onPointerDown(event) {
            // è¨ˆç®—æ»‘é¼ ä½ç½®
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            // æª¢æ¸¬èˆ‡ objects é™£åˆ—çš„äº¤é›† (éè¿´æª¢æŸ¥å­ç‰©ä»¶)
            const intersects = raycaster.intersectObjects(objects, true);

            if (intersects.length > 0) {
                // æ‰¾åˆ°æœ€ä¸Šå±¤çš„çˆ¶ç‰©ä»¶ (å› ç‚ºå¯èƒ½æ˜¯ Group çš„ä¸€éƒ¨åˆ†)
                let target = intersects[0].object;
                while(target.parent && target.parent !== scene && !objects.includes(target)) {
                    target = target.parent;
                }
                
                // å¦‚æœé»æ“Šçš„æ˜¯æˆ‘å€‘å®šç¾©çš„å¯ç·¨è¼¯ç‰©ä»¶
                if (objects.includes(target)) {
                    selectObject(target);
                    return;
                }
            }

            // å¦‚æœé»æ“Šç©ºç™½è™•ï¼Œå–æ¶ˆé¸å–
            deselectObject();
        }

        function selectObject(obj) {
            selectedObject = obj;
            transformControls.attach(obj);
            
            // æ›´æ–° UI é¡¯ç¤º
            noSelectionMsg.style.display = 'none';
            editPanel.style.display = 'block';
            
            // å˜—è©¦æŠ“å–é¡è‰²ä¸¦æ›´æ–° input (åªæŠ“ç¬¬ä¸€å€‹ Mesh çš„é¡è‰²)
            let mesh = obj;
            if (obj.isGroup) {
                obj.traverse((child) => {
                    if (child.isMesh && !mesh.isMesh) mesh = child;
                });
            }
            if (mesh.material && mesh.material.color) {
                colorInput.value = '#' + mesh.material.color.getHexString();
            }
        }

        function deselectObject() {
            selectedObject = null;
            transformControls.detach();
            noSelectionMsg.style.display = 'block';
            editPanel.style.display = 'none';
        }

        function deleteSelected() {
            if (!selectedObject) return;
            
            scene.remove(selectedObject);
            transformControls.detach();
            
            // å¾é™£åˆ—ä¸­ç§»é™¤
            const index = objects.indexOf(selectedObject);
            if (index > -1) objects.splice(index, 1);
            
            deselectObject();
        }

        function updateObjectColor(hexColor) {
            if (!selectedObject) return;
            
            const color = new THREE.Color(hexColor);
            
            if (selectedObject.isGroup) {
                selectedObject.traverse((child) => {
                    if (child.isMesh && child.name !== 'Eye') { // é¿å…æŠŠçœ¼ç›ä¹Ÿè®Šè‰²
                         child.material.color.set(color);
                    }
                });
            } else if (selectedObject.material) {
                selectedObject.material.color.set(color);
            }
        }

        // --- UI äº‹ä»¶è™•ç† ---
        function setupUIEvents() {
            // ç”¢ç”ŸæŒ‰éˆ•
            document.getElementById('add-gecko').addEventListener('click', createGecko);
            document.getElementById('add-rock').addEventListener('click', createRock);
            document.getElementById('add-plant').addEventListener('click', createPlant);
            document.getElementById('add-cave').addEventListener('click', createCave);
            document.getElementById('add-bowl').addEventListener('click', createBowl);

            // æ¨¡å¼åˆ‡æ›
            const modes = {
                'mode-translate': 'translate',
                'mode-rotate': 'rotate',
                'mode-scale': 'scale'
            };
            
            for (const [id, mode] of Object.entries(modes)) {
                document.getElementById(id).addEventListener('click', (e) => {
                    transformControls.setMode(mode);
                    // æ›´æ–°æŒ‰éˆ•æ¨£å¼
                    document.querySelectorAll('.mode-toggle button').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                });
            }

            // é¡è‰²ä¿®æ”¹
            colorInput.addEventListener('input', (e) => {
                updateObjectColor(e.target.value);
            });

            // åˆªé™¤
            document.getElementById('delete-obj').addEventListener('click', deleteSelected);
            
            // éµç›¤å¿«æ·éµ
            window.addEventListener('keydown', function(event) {
                switch (event.key) {
                    case 'Delete': // Deleteéµåˆªé™¤
                    case 'Backspace':
                        deleteSelected();
                        break;
                }
            });
        }

        function onWindowResize() {
            const container = document.getElementById('main-viewport');
            camera.aspect = container.offsetWidth / container.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.offsetWidth, container.offsetHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            orbitControls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>